#summary How to add new Java function packages to the MathEclipse core
#labels Phase-Implementation

= Object Hierarchy =

All atomic math objects like integer numbers ({{{IntegerSym}}}), fractional numbers ({{{FractionSym}}}), complex numbers ({{{ComplexSym}}}), numerical numbers ({{{Num, ComplexNum}}}), patterns ({{{Pattern}}}), strings ({{{StringX}}}) or symbols ({{{Symol}}}) are derived from {{{org.matheclipse.core.expression.ExprImpl}}}

The math functions are represented as AST (abstract syntax tree) objects (derived from {{{IAST}}}, {{{IExpr}}} and {{{java.util.List}}} interfaces). The *head* (i.e. Sin, Cos, PrimeQ,...) of the function is stored at index {{{0}}} in the list. The {{{n}}} arguments of the function are stored in the indexes {{{1..n}}}. For example the function {{{f[x,y,z]}}} is internally represented by the {{{java.util.ArrayList}}}: {{{[ f, x, y, z ]}}}. Of course these lists can be nested and form a tree of {{{java.util.List}}} and other atomic math objects (i.e. {{{f[x,y,g[u,v,h[w,3]]]}}} is represented by the nested {{{java.util.ArrayList}}} structure: {{{[ f, x, y, [ g, u, v [ h, w, 3 ] ] ]}}}).

Here is a hierarchy overview of the classes, which implement the internal math expression representation:
 
http://symja.googlecode.com/svn/wiki/MathEclipseObjectHierarchy.png

= Function Interfaces =
For your own Java math functions you have to add the Java package name to the system namespace:
{{{
SystemNamespace.DEFAULT.add("<your.own.package.name>");
}}}

In this package you have to define a class which is derived from the [http://code.google.com/p/symja/source/browse/trunk/matheclipse-core/src/main/java/org/matheclipse/core/eval/interfaces/IFunctionEvaluator.java org.matheclipse.core.eval.interfaces.IFunctionEvaluator] or [http://code.google.com/p/symja/source/browse/trunk/matheclipse-core/src/main/java/org/matheclipse/core/eval/interfaces/AbstractFunctionEvaluator.java org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator] interfaces.

If you would like to implement a new {{{MyFunction[<argument>]}}} function, you can for example derive a class with the same name ({{{MyFunction}}}) from {{{AbstractFunctionEvaluator}}}. In this class you have to define a public default constructor and an {{{evaluate()}}} method. The {{{evaluate()}}} method can return {{{null}}} if no new result could be evaluated.

{{{
public class MyFunction extends AbstractFunctionEvaluator {

  public MyFunction() {
  }

  @Override
  public IExpr evaluate(final IAST functionList) {
...

...
  }
}
}}}

= Example =

You can find a lot of examples in the [http://code.google.com/p/symja/source/browse/#svn/trunk/matheclipse-core/src/main/java/org/matheclipse/core/reflection/system org.matheclipse.core.reflection.system package].

Add your own package to the system namespace:
{{{
SystemNamespace.DEFAULT.add("org.matheclipse.test.function");
}}}

After defining a new {{{MyFuntion[]}}} function in your own package you can evaluate an expression like {{{MyFunction[Sin[x]*Cos[x]]}}}
{{{
package org.matheclipse.test.function;

import org.matheclipse.core.eval.interfaces.AbstractFunctionEvaluator;
import org.matheclipse.core.expression.AST;
import org.matheclipse.core.expression.F;
import org.matheclipse.core.interfaces.IAST;
import org.matheclipse.core.interfaces.IExpr;

/**
 * Calculate the <b>depth</b> of an expression 
 */
public class MyFunction extends AbstractFunctionEvaluator {

  public MyFunction() {
  }

  @Override
  public IExpr evaluate(final IAST functionList) {
    if (functionList.size() != 2) {
      // The size has to be 2 because the head is stored at index 0 and 
      // the argument is stored at index 1
      return null;
    }
    if (!(functionList.get(1) instanceof IAST)) {
      //constant integer 1:
      return F.C1;
    }
    return F.integer(AST.COPY.depth((IAST) functionList.get(1), 1));
  }

}
}}}